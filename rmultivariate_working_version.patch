diff --git a/DESCRIPTION b/DESCRIPTION
index f66dc67..b995d35 100644
--- a/DESCRIPTION
+++ b/DESCRIPTION
@@ -8,7 +8,11 @@ Description: This package simulates samples from a target probability distributi
 License: GPL (>= 3)
 Encoding: UTF-8
 LazyData: true
-Imports: Rcpp (>= 1.0.9)
+Imports: 
+    MASS,
+    Matrix,
+    Rcpp (>= 1.0.9),
+    stats
 LinkingTo: 
     Rcpp,
     RcppArmadillo
diff --git a/NAMESPACE b/NAMESPACE
index 79409c2..e3a5343 100644
--- a/NAMESPACE
+++ b/NAMESPACE
@@ -4,4 +4,5 @@ export(hello)
 export(rcpp_hello)
 importFrom(Rcpp, evalCpp)
 import(stats)
+import(MASS)
 useDynLib(RMetropolisHastings, .registration = TRUE)
diff --git a/R/MultivariateMetropolisHastings.r b/R/MultivariateMetropolisHastings.r
index 448b308..31f11c9 100644
--- a/R/MultivariateMetropolisHastings.r
+++ b/R/MultivariateMetropolisHastings.r
@@ -33,16 +33,17 @@ rmultivariatemh = function(targetdensity,  candidatedensity = c("Normal"),
   }
 
   # initialize the x matrix to capture the generated samples
-  x = matrix(c(initial_vec, rep(0, length(initial_vec) * (numIter - 1))), nrow = numIter, byrow = TRUE)
+  x = matrix(rep(0, length(initial_vec) * (numIter)), nrow = numIter, byrow = TRUE)
+  x[1, ] = initial_vec # initial the starting point
   set.seed(seed)
   #build the markov chain
   for(i in 2:numIter){
     # generate a  possible move in the markov chain
-    nextVal = rnorm(1, x[, i-1], sigma_matrix)
+    nextVal = mvrnorm(1, x[i-1,], sigma_matrix)
 
     #compute the acceptance probability
     #this is a special case because the candidate is symmetric
-    prevDensity = targetdensity(x[, i-1])
+    prevDensity = targetdensity(x[i-1, ])
     if(all(prevDensity == 0)){
       stop(paste('invalid value (0) returned by target density for x = ', x[, i-1]))
     }
@@ -51,10 +52,10 @@ rmultivariatemh = function(targetdensity,  candidatedensity = c("Normal"),
 
     #accept the sample with 'prob' probability
     if(u <= prob){
-      x[, i] = nextVal
+      x[i, ] = nextVal
     }
     else{
-      x[, i] = x[, i-1]
+      x[i, ] = x[i-1, ]
     }
   }
 
diff --git a/man/cppunivariatemh.Rd b/man/cppunivariatemh.Rd
index c07d6a2..91133da 100644
--- a/man/cppunivariatemh.Rd
+++ b/man/cppunivariatemh.Rd
@@ -16,9 +16,10 @@ cppunivariatemh(
 )
 }
 \arguments{
-\item{targetdensity}{This is the probability density function from which sampling will be done. This should be a function of x.}
+\item{targetdensity}{This is the probability density function from which sampling will be done. This should be one of the supported values:
+"Exponential"- Exponential distribution with lambda=1.}
 
-\item{candidatedensity}{This is the candidate generation density to be used}
+\item{candidatedensity}{This is the candidate generation density to be used. This should be one of the supported values}
 
 \item{numIter}{The number of samples to generate}
 
diff --git a/tests/testthat/test-rmultivariatemh.R b/tests/testthat/test-rmultivariatemh.R
index ffcd579..c74b8bf 100644
--- a/tests/testthat/test-rmultivariatemh.R
+++ b/tests/testthat/test-rmultivariatemh.R
@@ -1,6 +1,11 @@
 test_invalidinputs = test_that("test for invalid inputs", {
-  targetDensity = function(x){
-    return(ifelse(x<0,0,exp(-x)))
+  #need a target density that generates a single probability for a vector x
+  targetDensity_mv = function(x){
+    prob = rep(0, length(x))
+    for(i in 1:length(x)){
+      prob[i] = ifelse(x[i]<0,0,exp(-x))
+    }
+    return(max(prob))
   }
   #bad sigma matrix
   expect_error(rmultivariatemh(targetDensity, initial_vec = rep(1, 4), sigma_matrix = diag(-1, nrow = 4)))
@@ -18,20 +23,40 @@ test_invalidinputs = test_that("test for invalid inputs", {
 })
 
 test_reproducibility = test_that("test reproducibility of samples", {
-  targetDensity = function(x){
-    return(ifelse(x<0,0,exp(-x)))
+  skip_if_not_installed("Matrix") # need this for nearPD function
+
+  #need a target density that generates a single probability for a vector x
+  targetDensity_mv = function(x){
+    prob = rep(0, length(x))
+    for(i in 1:length(x)){
+      prob[i] = ifelse(x[i]<0,0,exp(-x))
+    }
+    return(max(prob))
   }
+
+  #construct a PD sigma matrix
+  n = 4
+  M = matrix(runif(n*n), ncol=n)
+  sigma_matrix = as.matrix(Matrix::nearPD(M)$mat)
+  initial_vec = c(0.5, 1.5, -1.65, 1.45)
   #test with same seed, same sigma
-  y1 = rmultivariatemh(targetDensity, initial_vec = rep(1, 4), sigma_matrix = diag(1, nrow = 4))
-  y2 = rmultivariatemh(targetDensity, initial_vec = rep(1, 4), sigma_matrix = diag(1, nrow = 4))
+  y1 = rmultivariatemh(targetDensity_mv, initial_vec = initial_vec, sigma_matrix = sigma_matrix)
+  y2 = rmultivariatemh(targetDensity_mv, initial_vec = initial_vec, sigma_matrix = sigma_matrix)
   expect_true(identical(y1, y2))
 
   #test with same seed, different sigma
-  y3 = rmultivariatemh(targetDensity, initial_vec = rep(1, 4), sigma_matrix = matrix(rep(5, 16), nrow = 4))
+  #construct a different PD sigma matrix
+  n = 4
+  M = matrix(runif(n*n), ncol=n)
+  sigma_matrix_1 = as.matrix(Matrix::nearPD(M)$mat)
+  y3 = rmultivariatemh(targetDensity_mv,
+                       initial_vec = initial_vec,
+                       sigma_matrix = sigma_matrix_1)
   expect_true(!identical(y3, y2))
 
   #test with different seed
-  y4 = rmultivariatemh(targetDensity, seed=30, initial_vec = rep(1, 4), sigma_matrix = diag(1, nrow = 4))
+  y4 = rmultivariatemh(targetDensity_mv, seed=30,
+                       initial_vec = initial_vec, sigma_matrix = sigma_matrix)
   expect_true(!identical(y4, y1))
 })
 
